name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-north-1
  ECR_REPOSITORY: cicd-demo
  ECS_SERVICE: cicd-demo-service
  ECS_CLUSTER: cicd-demo-cluster
  ECS_TASK_DEFINITION: cicd-demo-task

jobs:
  test:
    name: Test Application
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Run Python application test
      run: |
        echo "Testing Python application..."
        python hello_world.py
        echo "‚úÖ Application test passed!"

  version:
    name: Generate Version
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main'
    outputs:
      version: ${{ steps.version.outputs.version }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Generate semantic version
      id: version
      run: |
        # Get the latest tag or start with 1.0.0
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        # Remove 'v' prefix if present
        VERSION=${LATEST_TAG#v}
        
        # Split version into components
        IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
        MAJOR=${VERSION_PARTS[0]}
        MINOR=${VERSION_PARTS[1]}
        PATCH=${VERSION_PARTS[2]}
        
        # Check commit messages for version bump indicators
        COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline)
        
        if echo "$COMMITS" | grep -q "\[major\]"; then
          MAJOR=$((MAJOR + 1))
          MINOR=0
          PATCH=0
        elif echo "$COMMITS" | grep -q "\[minor\]"; then
          MINOR=$((MINOR + 1))
          PATCH=0
        else
          PATCH=$((PATCH + 1))
        fi
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    needs: [test, version]
    if: github.ref == 'refs/heads/main'
    permissions:
      id-token: write
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Create ECR repository if it doesn't exist
      run: |
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        
    - name: Build Docker image
      run: |
        VERSION=${{ needs.version.outputs.version }}
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        
        echo "üê≥ Building Docker image with version: $VERSION"
        
        # Build image with multiple tags
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        echo "‚úÖ Docker image built successfully"
        
    - name: Test Docker image
      run: |
        VERSION=${{ needs.version.outputs.version }}
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        
        echo "üß™ Testing Docker image..."
        docker run --rm $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION
        echo "‚úÖ Docker image test passed!"
        
    - name: Push Docker image to ECR
      run: |
        VERSION=${{ needs.version.outputs.version }}
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        
        echo "üì§ Pushing Docker image to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "‚úÖ Images pushed to ECR:"
        echo "  - $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION"
        echo "  - $ECR_REGISTRY/$ECR_REPOSITORY:latest"
        
    - name: Create and push Git tag
      run: |
        VERSION=${{ needs.version.outputs.version }}
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git tag -a "v$VERSION" -m "Release version $VERSION"
        git push https://${{ github.token }}@github.com/${{ github.repository }} "v$VERSION"
        
    - name: Update ECS task definition
      id: task-def
      run: |
        VERSION=${{ needs.version.outputs.version }}
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        
        # Create ECS task definition JSON
        cat > task-definition.json << EOF
        {
          "family": "$ECS_TASK_DEFINITION",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "cicd-demo",
              "image": "$ECR_REGISTRY/$ECR_REPOSITORY:$VERSION",
              "essential": true,
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/cicd-demo",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        
        echo "task-definition-file=task-definition.json" >> $GITHUB_OUTPUT
        
    - name: Create ECS cluster if it doesn't exist
      run: |
        echo "üèóÔ∏è Checking if ECS cluster exists..."
        
        # Check if cluster exists
        if aws ecs describe-clusters --clusters $ECS_CLUSTER --region $AWS_REGION --query 'clusters[0].clusterName' --output text 2>/dev/null | grep -q $ECS_CLUSTER; then
          echo "‚úÖ ECS cluster '$ECS_CLUSTER' already exists"
        else
          echo "üèóÔ∏è Creating ECS cluster '$ECS_CLUSTER'..."
          aws ecs create-cluster --cluster-name $ECS_CLUSTER --region $AWS_REGION
          
          # Wait for cluster to be active
          echo "‚è≥ Waiting for cluster to be active..."
          aws ecs wait cluster-active --clusters $ECS_CLUSTER --region $AWS_REGION
          echo "‚úÖ ECS cluster '$ECS_CLUSTER' is now active"
        fi
        
        # Verify cluster exists
        CLUSTER_STATUS=$(aws ecs describe-clusters --clusters $ECS_CLUSTER --region $AWS_REGION --query 'clusters[0].status' --output text)
        echo "Cluster status: $CLUSTER_STATUS"
        
    - name: Create CloudWatch log group if it doesn't exist
      run: |
        echo "üìä Setting up CloudWatch logs..."
        aws logs describe-log-groups --log-group-name-prefix "/ecs/cicd-demo" --region $AWS_REGION || \
        aws logs create-log-group --log-group-name "/ecs/cicd-demo" --region $AWS_REGION
        echo "‚úÖ CloudWatch log group ready"
        
    - name: Register ECS task definition
      run: |
        echo "üìã Registering task definition..."
        aws ecs register-task-definition \
          --cli-input-json file://task-definition.json \
          --region $AWS_REGION
        echo "‚úÖ Task definition registered"
        
    - name: Get default VPC info
      id: vpc-info
      run: |
        echo "üîç Getting VPC information..."
        # Get default VPC
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" --query 'Vpcs[0].VpcId' --output text --region $AWS_REGION)
        echo "VPC ID: $VPC_ID"
        
        # Get default subnets
        SUBNETS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[].SubnetId' --output text --region $AWS_REGION | tr '\t' ',')
        echo "Subnets: $SUBNETS"
        
        # Get default security group
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=default" --query 'SecurityGroups[0].GroupId' --output text --region $AWS_REGION)
        echo "Security Group: $SG_ID"
        
        echo "subnets=$SUBNETS" >> $GITHUB_OUTPUT
        echo "security-group=$SG_ID" >> $GITHUB_OUTPUT
        
    - name: Create or update ECS service
      run: |
        SUBNETS="${{ steps.vpc-info.outputs.subnets }}"
        SECURITY_GROUP="${{ steps.vpc-info.outputs.security-group }}"
        
        echo "üöÄ Deploying to ECS..."
        echo "Cluster: $ECS_CLUSTER"
        echo "Service: $ECS_SERVICE"
        echo "Subnets: $SUBNETS"
        echo "Security Group: $SECURITY_GROUP"
        
        # Double-check cluster exists before creating service
        echo "üîç Verifying cluster exists..."
        aws ecs describe-clusters --clusters $ECS_CLUSTER --region $AWS_REGION --query 'clusters[0].{Name:clusterName,Status:status}'
        
        # Check if service exists
        if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --region $AWS_REGION --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_SERVICE; then
          echo "üìù Service exists, updating..."
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $ECS_TASK_DEFINITION \
            --region $AWS_REGION
        else
          echo "üÜï Service doesn't exist, creating..."
          aws ecs create-service \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --task-definition $ECS_TASK_DEFINITION \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --region $AWS_REGION
        fi
        
        echo "‚úÖ ECS deployment completed"
        
    - name: Deployment Summary
      run: |
        VERSION=${{ needs.version.outputs.version }}
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        
        echo "üéâ Deployment Summary:"
        echo "  üì¶ Version: v$VERSION"
        echo "  üê≥ Docker Image: $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION"
        echo "  ‚òÅÔ∏è  AWS Region: $AWS_REGION"
        echo "  üìã ECS Cluster: $ECS_CLUSTER"
        echo "  üöÄ ECS Service: $ECS_SERVICE"
        echo ""
        echo "‚úÖ CI/CD Pipeline completed successfully!" 